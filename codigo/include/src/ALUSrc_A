#ifndef _MUX_2_ALUSrcA_
#define _MUX_2_ALUSrcA_

#include <pthread.h>
#include "mascara.h"

#define ALUOut 0

extern int pc;
extern int cpu_clock;

pthread_cond_t cs_ready;
pthread_mutex_t ALU_mux; //ALU_mux: nome generico para usar tambem no mux de 4 entradas?

void mux_2_ALUSrcA()
{
    int last_clock = 10;

    while(valid_instruction)
    {
		if (last_clock != cpu_clock)
		{
			pthread_mutex_lock(&control_sign);//nao seria para esperar a vez de ler a unidade de controle? &control_sign
///se este mutex acima bloquar acesso a unidade de controle, nao estariamos perdendo paralelismo?
			while(pthread_cond_wait(&cs_ready, &control_sign) != 0);//idle loop

            pthread_mutex_lock(&control_sign);

			//seguindo a logica dos outros muxes, tenho o mutex e a uc mandou o sinal verde
			if(( (separa_ALUSrcA & sc) >> ALUSrcA_POS) & 0x01 == 0)//verifico qual a entrada do mux
            {//entrada eh de pc (considerando discussoes, seria entao melhor fazer structs para atualizado?)
                pthread_mutex_lock(&pc_var);//seria necessario esses mutexes aqui? existiriam condicoes de deadlock?
                ///pthread_mutex_lock(&ALU_mux); se pthread_mutex_lock(&ALU_mux); da linha 22 bloquear acesso a UC, este mutex
                ///bloquearia o acesso a variavel do mux, ou seja a ula nao podeia ler dela enquanto atualizo seu valor
                mux_ALUSrcA_buffer = pc;
                ///pthread_mutex_unlock(&ALU_mux);
                pthread_mutex_unlock(&pc_var);
			}
			else
            {//entrada vem de A
                pthread_mutex_lock(&A_var);//bloqueia outros acessos a A.
                //pthread_mutex_lock(&ALU_mux);
                mux_ALUSrcA_buffer = A;
                //pthread_mutex_unlock(&ALU_mux);
                pthread_mutex_lock(&A_var);
            }

            last_clock = cpu_clock;


            pthread_barrier_wait(&current_cycle);
		}

        else pthread_yield();
    }

    pthread_exit(0);
}

#endif
